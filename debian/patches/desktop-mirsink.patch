From: =?utf-8?q?Alfonso_S=C3=A1nchez-Beato?= <alfonsosanchezbeato@yahoo.es>
Date: Tue, 14 Feb 2017 16:39:12 +0100
Subject: New mirsink for desktop usage

The mirsink works in two modes: if "export-buffers" property is set, it
exports dma buffers that are sent to the client by posting a GstMessage.
If not, it creates its own rendering Mir window.

From: Alfonso Sanchez-Beato <alfonso.sanchez-beato@canonical.com>
Origin: vendor
Forwarded: no
---
 configure.ac         |   13 +
 ext/Makefile.am      |    8 +
 ext/mir/Makefile.am  |   14 +
 ext/mir/gstmirsink.c | 1113 ++++++++++++++++++++++++++++++++++++++++++++++++++
 ext/mir/gstmirsink.h |  117 ++++++
 5 files changed, 1265 insertions(+)
 create mode 100644 ext/mir/Makefile.am
 create mode 100644 ext/mir/gstmirsink.c
 create mode 100644 ext/mir/gstmirsink.h

diff --git a/configure.ac b/configure.ac
index 7444429..54b1891 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1796,6 +1796,17 @@ AG_GST_CHECK_FEATURE(ANDROID_MEDIA_HYBRIS, [Android Media Hybris], androidmediah
       )], HAVE_ANDROID_MEDIA_HYBRIS="no")
 ])
 
+dnl *** A mir-based Platform ***
+translit(dnm, m, l) AM_CONDITIONAL(USE_MIR, true)
+HAVE_MIR="no"
+dnl Check for the presence of Mir client library
+AG_GST_CHECK_FEATURE(MIR, [Mir Server], mir, [
+      PKG_CHECK_MODULES(MIR, mirclient,
+              [HAVE_MIR="yes"],
+              [HAVE_MIR="no"]
+      )
+])
+
 dnl *** AppleMedia (OS X and iOS) ***
 translit(dnm, m, l) AM_CONDITIONAL(USE_APPLE_MEDIA, true)
 HAVE_APPLE_MEDIA="no"
@@ -3477,6 +3488,7 @@ AM_CONDITIONAL(USE_DIRECTFB, false)
 AM_CONDITIONAL(USE_WAYLAND, false)
 AM_CONDITIONAL(USE_DAALA, false)
 AM_CONDITIONAL(USE_ANDROID_MEDIA_HYBRIS, false)
+AM_CONDITIONAL(USE_MIR, false)
 AM_CONDITIONAL(USE_DTS, false)
 AM_CONDITIONAL(USE_EXIF, false)
 AM_CONDITIONAL(USE_RESINDVD, false)
@@ -3818,6 +3830,7 @@ ext/libde265/Makefile
 ext/libmms/Makefile
 ext/libvisual/Makefile
 ext/Makefile
+ext/mir/Makefile
 ext/modplug/Makefile
 ext/mpeg2enc/Makefile
 ext/mimic/Makefile
diff --git a/ext/Makefile.am b/ext/Makefile.am
index 709bdb2..3ff2fc9 100644
--- a/ext/Makefile.am
+++ b/ext/Makefile.am
@@ -76,6 +76,12 @@ else
 HYBRIS_DIR=
 endif
 
+if USE_MIR
+MIR_DIR=mir
+else
+MIR_DIR=
+endif
+
 if USE_DTS
 DTS_DIR=dts
 else
@@ -464,6 +470,7 @@ SUBDIRS=\
 	$(LIBMMS_DIR) \
 	$(LIBVISUAL_DIR) \
 	$(HYBRIS_DIR) \
+	$(MIR_DIR) \
 	$(MODPLUG_DIR) \
 	$(MPEG2ENC_DIR) \
 	$(MIMIC_DIR) \
@@ -516,6 +523,7 @@ DIST_SUBDIRS = \
 	directfb \
 	wayland \
 	hybris \
+	mir \
 	faac \
 	faad \
 	fdkaac \
diff --git a/ext/mir/Makefile.am b/ext/mir/Makefile.am
new file mode 100644
index 0000000..c691e7a
--- /dev/null
+++ b/ext/mir/Makefile.am
@@ -0,0 +1,14 @@
+plugin_LTLIBRARIES = libgstmirsink.la
+
+libgstmirsink_la_SOURCES = gstmirsink.c
+libgstmirsink_la_CFLAGS = $(GST_CFLAGS) $(GST_BASE_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) \
+                               $(MIR_CFLAGS) \
+                               -I../../gst-libs/
+libgstmirsink_la_LIBADD = $(GST_PLUGINS_BASE_LIBS) $(GST_BASE_LIBS) $(GST_LIBS) \
+                               -lgstvideo-$(GST_API_VERSION) \
+                               $(GL_LIBS) $(EGL_LIBS) $(EGLGLES_LIBS) \
+                               $(MIR_LIBS)
+libgstmirsink_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstmirsink_la_LIBTOOLFLAGS = $(GST_PLUGIN_LIBTOOLFLAGS)
+include_HEADERS = gstmirsink.h
+noinst_HEADERS =
diff --git a/ext/mir/gstmirsink.c b/ext/mir/gstmirsink.c
new file mode 100644
index 0000000..533ae67
--- /dev/null
+++ b/ext/mir/gstmirsink.c
@@ -0,0 +1,1113 @@
+/*
+ * GStreamer Mir video sink
+ * Copyright (C) 2017 Canonical Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ */
+
+/**
+ * SECTION:element-mirsink
+ *
+ *  The mirsink works in two modes: if "export-buffers" property is set, it
+ *  exports dma buffers that are sent to the client by posting a GstMessage.
+ *  If not, it creates its own rendering window.
+ *  TODO: a third mode where the rendering surface is provided by the client.
+ *
+ * <refsect2>
+ * <title>Example pipeline</title>
+ * |[
+ * gst-launch-1.0 filesrc location=<video_file> ! qtdemux ! queue ! \
+ *                h264parse ! avdec_h264 ! mirsink
+ * ]| test the video rendering with mirsink
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gstmirsink.h"
+
+/* signals */
+enum
+{
+  SIGNAL_0,
+  LAST_SIGNAL
+};
+
+/* Properties */
+enum
+{
+  PROP_0,
+  PROP_MIR_EXPORT_BUFFERS,
+  PROP_MIR_VIDEO_HEIGHT,
+  PROP_MIR_VIDEO_WIDTH
+};
+
+GST_DEBUG_CATEGORY (gstmir_debug);
+#define GST_CAT_DEFAULT gstmir_debug
+
+static GstStaticPadTemplate gst_mirsink_sink_caps_template =
+  GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE
+        ("{ BGRx, BGRA, RGBx, xBGR, xRGB, RGBA, ABGR, ARGB, RGB, BGR, "
+            "RGB16, BGR16, YUY2, YVYU, UYVY, AYUV, NV12, NV21, NV16, "
+            "YUV9, YVU9, Y41B, I420, YV12, Y42B, v308 }"))
+    );
+
+#define gst_mir_sink_parent_class parent_class
+G_DEFINE_TYPE (GstMirSink, gst_mir_sink, GST_TYPE_VIDEO_SINK);
+
+static void gst_mir_sink_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec);
+static void gst_mir_sink_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec);
+static void gst_mir_sink_finalize (GObject * object);
+static void gst_mir_sink_set_context (GstElement * element,
+    GstContext * context);
+static GstCaps *gst_mir_sink_get_caps (GstBaseSink * bsink, GstCaps * filter);
+static gboolean gst_mir_sink_set_caps (GstBaseSink * bsink, GstCaps * caps);
+static gboolean gst_mir_sink_start (GstBaseSink * bsink);
+static gboolean gst_mir_sink_stop (GstBaseSink * bsink);
+static gboolean gst_mir_sink_preroll (GstBaseSink * bsink, GstBuffer * buffer);
+static gboolean
+gst_mir_sink_propose_allocation (GstBaseSink * bsink, GstQuery * query);
+static gboolean gst_mir_sink_render (GstBaseSink * bsink, GstBuffer * buffer);
+static gboolean gst_mir_sink_query (GstBaseSink * bsink, GstQuery * query);
+
+static void
+gst_mir_sink_class_init (GstMirSinkClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+  GstBaseSinkClass *gstbasesink_class;
+
+  gobject_class = (GObjectClass *) klass;
+  gstelement_class = (GstElementClass *) klass;
+  gstbasesink_class = (GstBaseSinkClass *) klass;
+
+  gobject_class->set_property = gst_mir_sink_set_property;
+  gobject_class->get_property = gst_mir_sink_get_property;
+  gobject_class->finalize = GST_DEBUG_FUNCPTR (gst_mir_sink_finalize);
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&gst_mirsink_sink_caps_template));
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "Mir video sink", "Sink/Video",
+      "Output to Mir surface",
+      "Alfonso Sanchez-Beato <alfonso.sanchez-beato@canonical.com>");
+
+  //gstelement_class->change_state =
+  //    GST_DEBUG_FUNCPTR (gst_mir_sink_change_state);
+  gstelement_class->set_context = GST_DEBUG_FUNCPTR (gst_mir_sink_set_context);
+
+  gstbasesink_class->get_caps = GST_DEBUG_FUNCPTR (gst_mir_sink_get_caps);
+  gstbasesink_class->set_caps = GST_DEBUG_FUNCPTR (gst_mir_sink_set_caps);
+  gstbasesink_class->start = GST_DEBUG_FUNCPTR (gst_mir_sink_start);
+  gstbasesink_class->stop = GST_DEBUG_FUNCPTR (gst_mir_sink_stop);
+  gstbasesink_class->preroll = GST_DEBUG_FUNCPTR (gst_mir_sink_preroll);
+  gstbasesink_class->propose_allocation =
+      GST_DEBUG_FUNCPTR (gst_mir_sink_propose_allocation);
+  gstbasesink_class->render = GST_DEBUG_FUNCPTR (gst_mir_sink_render);
+  gstbasesink_class->query = GST_DEBUG_FUNCPTR (gst_mir_sink_query);
+
+  g_object_class_install_property (gobject_class, PROP_MIR_EXPORT_BUFFERS,
+      g_param_spec_boolean ("export-buffers", "Export buffers flag",
+          "If set, dma_buf fds with decoded video are exported", FALSE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_MIR_VIDEO_HEIGHT,
+      g_param_spec_uint ("height", "Video Height",
+          "Height of each video frame", 0,
+          UINT_MAX, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_MIR_VIDEO_WIDTH,
+      g_param_spec_uint ("width", "Video Width",
+          "Width of each video frame", 0,
+          UINT_MAX, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+}
+
+static void
+gst_mir_sink_init (GstMirSink * sink)
+{
+  GST_DEBUG_OBJECT (sink, "Initializing mirsink");
+  sink->pool = NULL;
+
+  sink->export_buffers = FALSE;
+
+  g_mutex_init (&sink->mir_lock);
+}
+
+static void
+gst_mir_sink_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstMirSink *sink = GST_MIR_SINK (object);
+
+  switch (prop_id) {
+    case PROP_MIR_EXPORT_BUFFERS:
+      g_value_set_boolean (value, sink->export_buffers);
+      break;
+    case PROP_MIR_VIDEO_HEIGHT:
+      g_value_set_uint (value, sink->video_height);
+      break;
+    case PROP_MIR_VIDEO_WIDTH:
+      g_value_set_uint (value, sink->video_width);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_mir_sink_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstMirSink *sink = GST_MIR_SINK (object);
+
+  switch (prop_id) {
+    case PROP_MIR_EXPORT_BUFFERS:
+      sink->export_buffers = g_value_get_boolean (value);
+      GST_INFO_OBJECT (object, "export_buffers set: %d", sink->export_buffers);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_mir_sink_finalize (GObject * object)
+{
+  GstMirSink *sink = GST_MIR_SINK (object);
+
+  GST_DEBUG_OBJECT (sink, "Finalizing the sink..");
+
+  g_mutex_clear (&sink->mir_lock);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gst_mir_sink_set_context (GstElement * element, GstContext * context)
+{
+  /* TODO Will handle reception of mir rendering window */
+  GST_INFO_OBJECT (element, "%s", __PRETTY_FUNCTION__);
+}
+
+static gboolean
+gst_mir_sink_query (GstBaseSink * bsink, GstQuery * query)
+{
+  GstMirSink *sink = GST_MIR_SINK (bsink);
+
+  GST_INFO_OBJECT (sink, "query type %s", GST_QUERY_TYPE_NAME (query));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_CONTEXT:
+    default:
+      goto base_class;
+      break;
+  }
+
+base_class:
+  return GST_BASE_SINK_CLASS (parent_class)->query (bsink, query);
+}
+
+static GstCaps *
+gst_mir_sink_get_caps (GstBaseSink * bsink, GstCaps * filter)
+{
+  GstMirSink *sink;
+  GstCaps *caps;
+
+  sink = GST_MIR_SINK (bsink);
+
+  GST_DEBUG_OBJECT (sink, "%s", __PRETTY_FUNCTION__);
+
+  caps = gst_pad_get_pad_template_caps (GST_VIDEO_SINK_PAD (sink));
+  if (filter) {
+    GstCaps *intersection;
+
+    intersection =
+        gst_caps_intersect_full (filter, caps, GST_CAPS_INTERSECT_FIRST);
+    gst_caps_unref (caps);
+    caps = intersection;
+  }
+  return caps;
+}
+
+static gboolean
+gst_mir_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
+{
+  GstMirSink *sink = GST_MIR_SINK (bsink);
+  GstVideoInfo info;
+  GstStructure *structure;
+  GstBufferPool *newpool;
+
+  sink = GST_MIR_SINK (bsink);
+
+  GST_DEBUG_OBJECT (sink, "set caps %" GST_PTR_FORMAT, caps);
+
+  if (!gst_video_info_from_caps (&info, caps))
+    goto invalid_format;
+
+  sink->video_width = info.width;
+  sink->video_height = info.height;
+  sink->video_format = (info.finfo)->format;
+
+  GST_DEBUG_OBJECT (sink, "sink->video_width: %u", sink->video_width);
+  GST_DEBUG_OBJECT (sink, "sink->video_height: %u", sink->video_height);
+  GST_DEBUG_OBJECT (sink, "Format %s (%s, %d)", (info.finfo)->description,
+      (info.finfo)->name, sink->video_format);
+  GST_DEBUG_OBJECT (sink, "Default allocator at 0x%p",
+      gst_allocator_find (NULL));
+
+  /* Create a new pool for the new configuration */
+  GST_DEBUG_OBJECT (sink, "Creating new GstBufferPool");
+  newpool = gst_video_buffer_pool_new ();
+  if (!newpool)
+    goto pool_failed;
+
+  structure = gst_buffer_pool_get_config (newpool);
+  /* Allocate a minimum of 2 buffers and an unlimited maximum (max=0) */
+  gst_buffer_pool_config_set_params (structure, caps, info.size, 2, 0);
+  /* Using default allocator for decoded buffers */
+  gst_buffer_pool_config_set_allocator (structure, gst_allocator_find (NULL),
+      NULL);
+  if (!gst_buffer_pool_set_config (newpool, structure))
+    goto config_failed;
+
+  gst_object_replace ((GstObject **) & sink->pool, (GstObject *) newpool);
+  gst_object_unref (newpool);
+
+  GST_DEBUG_OBJECT (sink, "Finishing up set_caps");
+
+  return TRUE;
+
+invalid_format:
+  {
+    GST_DEBUG_OBJECT (sink,
+        "Could not locate image format from caps %" GST_PTR_FORMAT, caps);
+    return FALSE;
+  }
+pool_failed:
+  {
+    GST_DEBUG_OBJECT (sink, "Failed to create new pool");
+    return FALSE;
+  }
+config_failed:
+  {
+    GST_DEBUG_OBJECT (bsink, "failed setting config");
+    gst_object_unref (newpool);
+    return FALSE;
+  }
+}
+
+/* vertex shader */
+static const char vshadersrc[] =
+  "attribute vec4 attrpos;\n"
+  "attribute vec2 attrcordY;\n"
+  "attribute vec2 attrcordU;\n"
+  "attribute vec2 attrcordV;\n"
+  "varying vec2 cordY;\n"
+  "varying vec2 cordU;\n"
+  "varying vec2 cordV;\n"
+  "\n"
+  "void main ()\n"
+  "{\n"
+  "  cordY = attrcordY;\n"
+  "  cordU = attrcordU;\n"
+  "  cordV = attrcordV;\n"
+  "  gl_Position = attrpos;\n"
+  "}\n";
+
+/* fragment shader */
+static const char fshadersrc[] =
+  "precision mediump float;\n"
+  "uniform sampler2D sampY;\n"
+  "uniform sampler2D sampU;\n"
+  "uniform sampler2D sampV;\n"
+  "uniform mat4 yuvmat;\n"
+  "varying vec2 cordY;\n"
+  "varying vec2 cordU;\n"
+  "varying vec2 cordV;\n"
+  "\n"
+  "/* Convert YV12 to RGB */\n"
+  "void main()\n"
+  "{\n"
+  "  vec4 yuv, rgb;\n"
+  "\n"
+  "  yuv.rgba = vec4(texture2D(sampY, cordY).r,\n"
+  "                  texture2D(sampU, cordU).r - 0.5,\n"
+  "                  texture2D(sampV, cordV).r - 0.5,\n"
+  "                  1.0);\n"
+  "\n"
+  "  rgb = yuvmat * yuv;\n"
+  "  gl_FragColor = rgb;\n"
+  "}\n";
+
+/* YUV to RGB conversion matrix */
+static GLfloat yuv_coef_bt601[4][4] =
+{
+  { 1.0f,      1.0f,     1.0f,     0.0f },
+  { 0.0f,     -0.344f,   1.773f,   0.0f },
+  { 1.403f,   -0.714f,   0.0f,     0.0f },
+  { 0.0f,      0.0f,     0.0f,     1.0f }
+};
+
+/* Set vertex coordinates to (-1,1), (1,1), (1,-1), (-1,-1), so we fill all
+ * the virtual device surface.
+ */
+static GLfloat dest_vert[4][2] =
+{ { -1.f, 1.f }, { 1.f, 1.f }, { 1.f, -1.f }, { -1.f, -1.f } };
+
+/* Set texture coordinates to (0,0), (1,0), (1,1), (0,1) so we cover fully the
+ * drawn surface. Note that texture coordinates have a [0,1] range.
+ */
+static GLfloat tex_vert[3][4][2] =
+{
+  { { 0.f, 0.f }, { 1.f, 0.f }, { 1.f, 1.f }, { 0.f, 1.f } },
+  { { 0.f, 0.f }, { 1.f, 0.f }, { 1.f, 1.f }, { 0.f, 1.f } },
+  { { 0.f, 0.f }, { 1.f, 0.f }, { 1.f, 1.f }, { 0.f, 1.f } },
+};
+
+static gboolean
+gl_error(GstMirSink *sink)
+{
+  GLenum err;
+  gboolean is_gl_err = FALSE;
+
+  while((err = glGetError()) != GL_NO_ERROR) {
+    GST_ERROR_OBJECT (sink, "OpenGL error %d (0x%X)", err, err);
+    is_gl_err = TRUE;
+  }
+
+  return is_gl_err;
+}
+
+static GLuint
+load_shader (GstMirSink *sink, const char *src, GLenum type)
+{
+  GLuint shader = glCreateShader (type);
+  GLint compiled;
+
+  if (!shader)
+    goto exit;
+
+  glShaderSource (shader, 1, &src, NULL);
+  glCompileShader (shader);
+  glGetShaderiv (shader, GL_COMPILE_STATUS, &compiled);
+
+  if (!compiled) {
+    GLchar log[1024];
+
+    glGetShaderInfoLog (shader, sizeof log - 1, NULL, log);
+    log[sizeof log - 1] = '\0';
+    GST_ERROR_OBJECT (sink, "load_shader compile failed: %s", log);
+    glDeleteShader (shader);
+    shader = 0;
+  }
+
+exit:
+  return shader;
+}
+
+static gboolean
+create_shaders (GstMirSink *sink)
+{
+  GLint linked;
+  int i;
+
+  sink->vshader = load_shader (sink, vshadersrc, GL_VERTEX_SHADER);
+  if (!sink->vshader) {
+    GST_ERROR_OBJECT (sink, "Cannot create vertex shader for mirsink");
+    goto error;
+  }
+  sink->fshader = load_shader (sink, fshadersrc, GL_FRAGMENT_SHADER);
+  if (!sink->fshader) {
+    GST_ERROR_OBJECT (sink, "Cannot create fragment shader for mirsink");
+    goto error;
+  }
+  sink->prog = glCreateProgram ();
+  if (!sink->prog) {
+    GST_ERROR_OBJECT (sink, "Cannot create GLSL program");
+    goto error;
+  }
+  glAttachShader (sink->prog, sink->vshader);
+  glAttachShader (sink->prog, sink->fshader);
+  glLinkProgram (sink->prog);
+
+  glGetProgramiv (sink->prog, GL_LINK_STATUS, &linked);
+  if (!linked) {
+    GLchar log[1024];
+    glGetProgramInfoLog (sink->prog, sizeof log - 1, NULL, log);
+    log[sizeof log - 1] = '\0';
+    GST_ERROR_OBJECT (sink, "Link failed: %s", log);
+    goto error;
+  }
+
+  glUseProgram (sink->prog);
+
+  sink->attrpos = glGetAttribLocation (sink->prog, "attrpos");
+  sink->attrcordYUV[0] = glGetAttribLocation (sink->prog, "attrcordY");
+  sink->attrcordYUV[1] = glGetAttribLocation (sink->prog, "attrcordU");
+  sink->attrcordYUV[2] = glGetAttribLocation (sink->prog, "attrcordV");
+  sink->sampYUV[0] = glGetUniformLocation (sink->prog, "sampY");
+  sink->sampYUV[1] = glGetUniformLocation (sink->prog, "sampU");
+  sink->sampYUV[2] = glGetUniformLocation (sink->prog, "sampV");
+  sink->yuvmat = glGetUniformLocation (sink->prog, "yuvmat");
+
+  /* Set shader variables */
+
+  glUniformMatrix4fv (sink->yuvmat, 1, GL_FALSE, &yuv_coef_bt601[0][0]);
+
+  /* Missing components filled by specification with (0,0,0,1) */
+  glVertexAttribPointer (sink->attrpos, 2, GL_FLOAT, GL_FALSE, 0, dest_vert);
+  glEnableVertexAttribArray (sink->attrpos);
+
+  for (i = 0; i < G_N_ELEMENTS (sink->attrcordYUV); ++i) {
+    glVertexAttribPointer (sink->attrcordYUV[i], 2, GL_FLOAT,
+        GL_FALSE, 0, tex_vert[i]);
+    glEnableVertexAttribArray (sink->attrcordYUV[i]);
+  }
+
+  /* Create textures for YUV planes */
+  glGenTextures (G_N_ELEMENTS (sink->text_id), sink->text_id);
+
+  for (i = 0; i < G_N_ELEMENTS (sink->attrcordYUV); ++i) {
+    /* GL_TEXTUREi = GL_TEXTURE0 + i is guaranteed */
+    /* Looks like OGLES selects the first free texture anyway, so calling
+     * glActiveTexture here is not a must. But it is needed when rendering. */
+    glActiveTexture (GL_TEXTURE0 + i);
+    glBindTexture (GL_TEXTURE_2D, sink->text_id[i]);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    glUniform1i (sink->sampYUV[i], i);
+  }
+
+  if (gl_error (sink))
+    goto error;
+
+  return TRUE;
+
+error:
+  glDeleteTextures (G_N_ELEMENTS (sink->text_id), sink->text_id);
+  /* So we know they do not exist anymore */
+  memset (sink->text_id, 0, sizeof sink->text_id);
+
+  glDisableVertexAttribArray (sink->attrpos);
+  sink->attrpos = 0;
+  for (i = 0; i < G_N_ELEMENTS (sink->attrcordYUV); ++i)
+    glDisableVertexAttribArray (sink->attrcordYUV[i]);
+  /* So we know they do not exist anymore */
+  memset (sink->attrcordYUV, 0, sizeof sink->attrcordYUV);
+
+  glDeleteShader (sink->vshader);
+  glDeleteShader (sink->fshader);
+  glDeleteProgram (sink->prog);
+  sink->vshader = 0;
+  sink->fshader = 0;
+  sink->prog = 0;
+
+  return FALSE;
+}
+
+static void
+mir_eglapp_handle_event (MirWindow *surface, MirEvent const *ev, void *ctx)
+{
+  GstMirSink *sink = ctx;
+
+  switch (mir_event_get_type (ev)) {
+  case mir_event_type_input:
+  case mir_event_type_surface:
+  case mir_event_type_resize:
+    break;
+  case mir_event_type_close_surface:
+    /* TODO Stop streaming if this happens. Handle locking. */
+    GST_DEBUG_OBJECT (sink, "Received close event from server");
+    break;
+  default:
+    break;
+  }
+}
+
+static const MirOutput *
+find_active_output (const MirDisplayConfig *conf)
+{
+  int num_outputs = mir_display_config_get_num_outputs (conf);
+  int i;
+
+  for (i = 0; i < num_outputs; ++i) {
+    MirOutput const *output = mir_display_config_get_output (conf, i);
+    MirOutputConnectionState state = mir_output_get_connection_state (output);
+
+    if (state == mir_output_connection_state_connected &&
+        mir_output_is_enabled (output))
+      return output;
+  }
+
+  return NULL;
+}
+
+static EGLSurface
+create_window (GstMirSink *sink, EGLConfig eglconfig)
+{
+  MirEGLNativeWindowType mir_window;
+  MirDisplayConfig *display_config = NULL;
+  const MirOutput *display_output;
+  const MirOutputMode *display_mode;
+  int pos_x, pos_y;
+  MirWindowSpec *spec = NULL;
+  MirPixelFormat pixel_format;
+  int width, height;
+  MirBufferStream *buff_stream;
+
+  pixel_format = mir_connection_get_egl_pixel_format (sink->conn,
+      sink->egldisplay, eglconfig);
+
+  GST_DEBUG_OBJECT (sink, "Mir chose format %d", pixel_format);
+  /* As we are opaque then it's OK to switch pixel format slightly,
+   * to enable bypass/overlays to work. Otherwise the presence of an
+   * alpha channel would prevent them from being used.
+   * It would be really nice if Mesa just gave us the right answer in
+   * the first place though. (LP: #1480755)
+   */
+  if (pixel_format == mir_pixel_format_abgr_8888)
+    pixel_format = mir_pixel_format_xbgr_8888;
+  else if (pixel_format == mir_pixel_format_argb_8888)
+    pixel_format = mir_pixel_format_xrgb_8888;
+  GST_DEBUG_OBJECT (sink, "Selected format is %d", pixel_format);
+
+  display_config = mir_connection_create_display_configuration (sink->conn);
+  display_output = find_active_output (display_config);
+  if (!display_output) {
+    GST_ERROR_OBJECT (sink, "There is no active output");
+    goto error;
+  }
+
+  display_mode = mir_output_get_current_mode (display_output);
+  if (!display_mode) {
+    GST_ERROR_OBJECT (sink, "No default mode for output");
+    goto error;
+  }
+
+  pos_x = mir_output_get_position_x (display_output);
+  pos_y = mir_output_get_position_y (display_output);
+
+  width  = mir_output_mode_get_width (display_mode);
+  height = mir_output_mode_get_height (display_mode);
+
+  GST_DEBUG_OBJECT (sink, "Current active output is %dx%d %+d%+d\n",
+      width, height, pos_x, pos_y);
+
+  mir_display_config_release (display_config);
+
+  spec = mir_create_normal_window_spec (sink->conn, width, height);
+  mir_window_spec_set_pixel_format (spec, pixel_format);
+  mir_window_spec_set_name (spec, "mirsink");
+
+  sink->window = mir_create_window_sync (spec);
+  mir_window_spec_release (spec);
+
+  if (!mir_window_is_valid (sink->window)) {
+    GST_ERROR_OBJECT (sink, "Cannot create valid window");
+    goto error;
+  }
+
+  mir_window_set_event_handler (sink->window, mir_eglapp_handle_event, sink);
+
+  buff_stream = mir_window_get_buffer_stream (sink->window);
+  mir_window = mir_buffer_stream_get_egl_native_window (buff_stream);
+
+  return eglCreateWindowSurface (sink->egldisplay, eglconfig,
+      (EGLNativeWindowType) mir_window, NULL);
+
+error:
+  if (sink->window) {
+    mir_window_release_sync (sink->window);
+    sink->window = NULL;
+  }
+  if (display_config)
+    mir_display_config_release (display_config);
+
+  return EGL_NO_SURFACE;
+}
+
+static gboolean
+gst_mir_sink_start (GstBaseSink * bsink)
+{
+  GstMirSink *sink = (GstMirSink *) bsink;
+
+  GST_DEBUG_OBJECT (sink, "start");
+
+  return TRUE;
+}
+
+static gboolean
+gst_mir_sink_stop (GstBaseSink * bsink)
+{
+  GstMirSink *sink = (GstMirSink *) bsink;
+  int i;
+
+  GST_DEBUG_OBJECT (sink, "stop");
+
+  /* Clean up GL stuff */
+
+  if (sink->buf_fd) {
+    close (sink->buf_fd);
+    sink->buf_fd = 0;
+  }
+
+  glDeleteFramebuffers(1, &sink->fbo);
+  sink->fbo = 0;
+  glDeleteTextures (1, &sink->render_tex);
+  sink->render_tex = 0;
+
+  glDeleteTextures (G_N_ELEMENTS (sink->text_id), sink->text_id);
+  memset (sink->text_id, 0, sizeof sink->text_id);
+
+  glDisableVertexAttribArray (sink->attrpos);
+  sink->attrpos = 0;
+  for (i = 0; i < G_N_ELEMENTS (sink->attrcordYUV); ++i)
+    glDisableVertexAttribArray (sink->attrcordYUV[i]);
+  memset (sink->attrcordYUV, 0, sizeof sink->attrcordYUV);
+
+  glDeleteShader (sink->vshader);
+  glDeleteShader (sink->fshader);
+  glDeleteProgram (sink->prog);
+  sink->vshader = 0;
+  sink->fshader = 0;
+  sink->prog = 0;
+
+  /* Clean up EGL stuff */
+
+  if (sink->egldisplay != EGL_NO_DISPLAY) {
+    if (sink->eglsurface != EGL_NO_SURFACE) {
+      eglDestroySurface (sink->egldisplay, sink->eglsurface);
+      sink->eglsurface = EGL_NO_SURFACE;
+    }
+    if (sink->eglctx != EGL_NO_CONTEXT) {
+      eglDestroyContext (sink->egldisplay, sink->eglctx);
+      sink->eglctx = EGL_NO_CONTEXT;
+    }
+    eglTerminate (sink->egldisplay);
+    sink->egldisplay = EGL_NO_DISPLAY;
+  }
+
+  /* Clean up Mir stuff */
+
+  if (sink->window) {
+    mir_window_release_sync (sink->window);
+    sink->window = NULL;
+  }
+  if (sink->conn) {
+    mir_connection_release (sink->conn);
+    sink->conn = NULL;
+  }
+
+  /* The pool is not re-used so must be destroyed here */
+  if (sink->pool) {
+    gst_object_unref (sink->pool);
+    sink->pool = NULL;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+gst_mir_sink_propose_allocation (GstBaseSink * bsink, GstQuery * query)
+{
+  GstMirSink *sink = GST_MIR_SINK (bsink);
+  GstStructure *config;
+  guint size, min_bufs, max_bufs;
+
+  GST_DEBUG_OBJECT (sink, "Proposing ALLOCATION params");
+
+  config = gst_buffer_pool_get_config (sink->pool);
+  gst_buffer_pool_config_get_params (config, NULL, &size, &min_bufs, &max_bufs);
+
+  /* we do have a pool for sure (created in set_caps),
+   * so let's propose it anyway, but also propose the allocator on its own
+   */
+  gst_query_add_allocation_pool (query, sink->pool, size, min_bufs, max_bufs);
+  gst_query_add_allocation_param (query, gst_allocator_find (NULL), NULL);
+
+  gst_structure_free (config);
+
+  return TRUE;
+}
+
+static GstFlowReturn
+gst_mir_sink_preroll (GstBaseSink * bsink, GstBuffer * buffer)
+{
+  GST_DEBUG_OBJECT (bsink, "preroll buffer %p", buffer);
+  return gst_mir_sink_render (bsink, buffer);
+}
+
+static PFNEGLCREATEIMAGEKHRPROC _eglCreateImageKHR;
+static PFNEGLDESTROYIMAGEKHRPROC _eglDestroyImageKHR;
+static PFNEGLEXPORTDMABUFIMAGEQUERYMESAPROC _eglExportDMABUFImageQueryMESA;
+static PFNEGLEXPORTDMABUFIMAGEMESAPROC _eglExportDMABUFImageMESA;
+
+static gboolean
+find_extension (const char *extensions, const char *ext)
+{
+    const char *found = strstr (extensions, ext);
+    int name_len = strlen (ext);
+
+    for (; found; found = strstr (found + name_len, ext)) {
+      if (found[name_len] == ' ' || found[name_len] == '\0')
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static gboolean
+import_egl_extensions (GstMirSink *sink)
+{
+  /* EGL_KHR_image_base: for eglCreateImageKHR/eglDestroyImageKHR
+   * EGL_MESA_image_dma_buf_export: for eglExportDMABUFImage*MESA
+   * EGL_KHR_surfaceless_context: to render without a surface
+   */
+  static const char *ext_str[] = { "EGL_KHR_image_base",
+                                   "EGL_MESA_image_dma_buf_export",
+                                   "EGL_KHR_surfaceless_context"};
+  const char *extensions;
+  int i;
+
+  extensions = eglQueryString (sink->egldisplay, EGL_EXTENSIONS);
+  if (!extensions)
+    return FALSE;
+
+  for (i = 0; i < G_N_ELEMENTS (ext_str); ++i) {
+    if (!find_extension (extensions, ext_str[i])) {
+      GST_ERROR_OBJECT (sink, "EGL extension %s not found", ext_str[i]);
+      return FALSE;
+    }
+  }
+
+  _eglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC)
+      eglGetProcAddress("eglCreateImageKHR");
+  _eglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC)
+      eglGetProcAddress("eglDestroyImageKHR");
+  _eglExportDMABUFImageQueryMESA = (PFNEGLEXPORTDMABUFIMAGEQUERYMESAPROC)
+      eglGetProcAddress("eglExportDMABUFImageQueryMESA");
+  _eglExportDMABUFImageMESA = (PFNEGLEXPORTDMABUFIMAGEMESAPROC)
+      eglGetProcAddress("eglExportDMABUFImageMESA");
+
+  if (!_eglCreateImageKHR || !_eglDestroyImageKHR ||
+      !_eglExportDMABUFImageQueryMESA || !_eglExportDMABUFImageMESA) {
+    GST_ERROR_OBJECT (sink, "Cannot load EGL extensions");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+export_buffers (GstMirSink *sink)
+{
+  EGLImageKHR egl_image = EGL_NO_IMAGE_KHR;
+  EGLint image_attrs[] = {
+    EGL_GL_TEXTURE_LEVEL_KHR, 0, /* mip map level to reference */
+    EGL_IMAGE_PRESERVED_KHR, EGL_FALSE,
+    EGL_NONE
+  };
+  EGLBoolean ok;
+  int fourcc, num_planes;
+  EGLuint64KHR modifiers;
+  EGLint stride, offset;
+
+  if (!import_egl_extensions (sink))
+    goto error;
+
+  /* Create and configure rendering texture */
+  glGenTextures (1, &sink->render_tex);
+  glActiveTexture (GL_TEXTURE3);
+  glBindTexture (GL_TEXTURE_2D, sink->render_tex);
+  glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA,
+                sink->video_width, sink->video_height, 0,
+                GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+  /* Generate framebuffer object */
+  glGenFramebuffers (1, &sink->fbo);
+  /* Set as target for rendering */
+  glBindFramebuffer (GL_FRAMEBUFFER, sink->fbo);
+  glFramebufferTexture2D (GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
+                          sink->render_tex, 0);
+
+  if (gl_error (sink))
+    goto error;
+
+  /* Create EGL image from rendering texture */
+
+  egl_image = _eglCreateImageKHR(sink->egldisplay, sink->eglctx,
+                                 EGL_GL_TEXTURE_2D_KHR,
+                                 (EGLClientBuffer) (long) sink->render_tex, image_attrs);
+  if (egl_image == EGL_NO_IMAGE_KHR) {
+    GST_ERROR_OBJECT (sink, "eglCreateImageKHR error 0x%x", eglGetError());
+    goto error;
+  }
+
+  /* Now get dma_buf file descriptor and related data */
+
+  ok = _eglExportDMABUFImageQueryMESA (sink->egldisplay, egl_image,
+                                       &fourcc, &num_planes, &modifiers);
+  if (!ok) {
+    GST_ERROR_OBJECT (sink, "eglExportDMABUFImageQueryMESA error 0x%x",
+                      eglGetError());
+    goto error;
+  }
+
+  ok = _eglExportDMABUFImageMESA (sink->egldisplay, egl_image,
+                                  &sink->buf_fd, &stride, &offset);
+  if (!ok) {
+    GST_ERROR_OBJECT (sink, "eglExportDMABUFImageMESA error 0x%x",
+                      eglGetError());
+    goto error;
+  }
+
+  ok = _eglDestroyImageKHR (sink->egldisplay, egl_image);
+  if (!ok)
+    GST_ERROR_OBJECT (sink, "eglDestroyImageKHR error 0x%x",
+                      eglGetError());
+
+  /* Post message with export data to application */
+  gst_element_post_message (GST_ELEMENT (sink),
+      gst_message_new_custom (GST_MESSAGE_ELEMENT, GST_OBJECT (sink),
+          gst_structure_new ("buffer-export-data",
+                             "fd", G_TYPE_INT, sink->buf_fd,
+                             "width", G_TYPE_INT, sink->video_width,
+                             "height", G_TYPE_INT, sink->video_height,
+                             "fourcc", G_TYPE_INT, fourcc,
+                             "stride", G_TYPE_INT, stride,
+                             "offset", G_TYPE_INT, offset,
+                             NULL)));
+
+  return TRUE;
+
+error:
+  if (sink->buf_fd) {
+    close (sink->buf_fd);
+    sink->buf_fd = 0;
+  }
+
+  if (egl_image != EGL_NO_IMAGE_KHR)
+    _eglDestroyImageKHR (sink->egldisplay, egl_image);
+
+  glDeleteFramebuffers(1, &sink->fbo);
+  sink->fbo = 0;
+  glDeleteTextures (1, &sink->render_tex);
+  sink->render_tex = 0;
+
+  return FALSE;
+}
+
+static gboolean
+init_renderer (GstMirSink *sink)
+{
+  EGLBoolean ok;
+  EGLConfig eglconfig;
+  EGLint neglconfigs;
+  const EGLint attribs[] = {
+    EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+    EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+    EGL_RED_SIZE, 8,
+    EGL_GREEN_SIZE, 8,
+    EGL_BLUE_SIZE, 8,
+    EGL_ALPHA_SIZE, 0,
+    EGL_NONE
+  };
+  EGLint ctxattribs[] = {
+    EGL_CONTEXT_CLIENT_VERSION, 2,
+    EGL_NONE
+  };
+
+  /* Use default server */
+  sink->conn = mir_connect_sync (NULL, "mirsink");
+  if (!mir_connection_is_valid (sink->conn)) {
+    GST_ERROR_OBJECT (sink, "Cannot create Mir connection");
+    goto error;
+  }
+
+  sink->egldisplay = eglGetDisplay (
+      mir_connection_get_egl_native_display (sink->conn));
+  if (sink->egldisplay == EGL_NO_DISPLAY) {
+    GST_ERROR_OBJECT (sink, "Cannot create egl display");
+    goto error;
+  }
+
+  ok = eglInitialize (sink->egldisplay, NULL, NULL);
+  if (!ok) {
+    GST_ERROR_OBJECT (sink, "Cannot initialize egl");
+    goto error;
+  }
+
+  ok = eglChooseConfig (sink->egldisplay, attribs, &eglconfig, 1, &neglconfigs);
+  if (!ok) {
+    GST_ERROR_OBJECT (sink, "Cannot configure egl");
+    goto error;
+  }
+  if (neglconfigs < 1) {
+    GST_ERROR_OBJECT (sink, "no egl config available");
+    goto error;
+  }
+
+  /* If exporting, use EGL_KHR_surfaceless_context so we can render offscreen.
+   * Otherwise, create a Mir window.
+   */
+  if (sink->export_buffers) {
+    sink->eglsurface = EGL_NO_SURFACE;
+  } else {
+    sink->eglsurface = create_window (sink, eglconfig);
+    if (sink->eglsurface == EGL_NO_SURFACE)
+      goto error;
+  }
+
+  sink->eglctx =
+    eglCreateContext (sink->egldisplay, eglconfig, EGL_NO_CONTEXT, ctxattribs);
+  if (sink->eglctx == EGL_NO_CONTEXT) {
+    GST_ERROR_OBJECT (sink, "eglCreateContext failed");
+    goto error;
+  }
+  ok =
+    eglMakeCurrent (sink->egldisplay, sink->eglsurface, sink->eglsurface,
+        sink->eglctx);
+  if (!ok) {
+    GST_ERROR_OBJECT (sink, "eglMakeCurrent failed");
+    goto error;
+  }
+
+  /* Configure shaders */
+  if (!create_shaders (sink))
+    goto error;
+
+  /* Proceed to export buffers*/
+  if (sink->export_buffers)
+    if (!export_buffers (sink))
+      goto error;
+
+  return TRUE;
+
+error:
+  if (sink->egldisplay != EGL_NO_DISPLAY) {
+    if (sink->eglsurface != EGL_NO_SURFACE) {
+      eglDestroySurface (sink->egldisplay, sink->eglsurface);
+      sink->eglsurface = EGL_NO_SURFACE;
+    }
+    if (sink->eglctx != EGL_NO_CONTEXT) {
+      eglDestroyContext (sink->egldisplay, sink->eglctx);
+      sink->eglctx = EGL_NO_CONTEXT;
+    }
+    eglTerminate (sink->egldisplay);
+    sink->egldisplay = EGL_NO_DISPLAY;
+  }
+  if (sink->conn) {
+    mir_connection_release (sink->conn);
+    sink->conn = NULL;
+  }
+  return FALSE;
+}
+
+static GstFlowReturn
+gst_mir_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
+{
+  GstMirSink *sink = GST_MIR_SINK (bsink);
+  GstMapInfo src;
+  guint8 *next_plane;
+  int i;
+  /* Determines order of triangle strip */
+  GLubyte idx[4] = { 0, 1, 3, 2 };
+  EGLint width, height;
+  EGLBoolean ok;
+
+  GST_DEBUG_OBJECT (sink, "render buffer 0x%p", buffer);
+
+  /* Surface *must* be created in the rendering thread */
+  if (!sink->conn)
+    if (!init_renderer (sink))
+      return GST_FLOW_ERROR;
+
+  gst_buffer_map (buffer, &src, GST_MAP_READ);
+
+  /* Associate YUV planes to our textures */
+  /* TODO Can we have stride in the input buffers? how to know? */
+  for (i = 0, next_plane = src.data; i < 3; ++i) {
+    /* GL_TEXTUREi = GL_TEXTURE0 + i is guaranteed */
+    glActiveTexture (GL_TEXTURE0 + i);
+    glTexImage2D (GL_TEXTURE_2D, 0, GL_LUMINANCE,
+        i == 0 ? sink->video_width : sink->video_width / 2,
+        i == 0 ? sink->video_height : sink->video_height / 2,
+        0, GL_LUMINANCE, GL_UNSIGNED_BYTE,
+        next_plane);
+    next_plane += (sink->video_width * sink->video_height) / (i == 0 ? 1 : 4);
+  }
+
+  if (sink->export_buffers) {
+    glViewport (0, 0, sink->video_width, sink->video_height);
+  } else {
+    if (eglQuerySurface (sink->egldisplay, sink->eglsurface, EGL_WIDTH, &width) &&
+        eglQuerySurface (sink->egldisplay, sink->eglsurface, EGL_HEIGHT, &height)) {
+      GST_DEBUG_OBJECT (sink, "Output size is %d x %d", width, height);
+      glViewport (0, 0, width, height);
+    }
+  }
+
+  /* Perform YUV -> RGB conversion by using GLSL shaders, and draw */
+  glDrawElements (GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, idx);
+
+  /* Just print the errors */
+  gl_error (sink);
+
+  if (sink->export_buffers) {
+    /* Notify texture ready (TODO: use explicit fences when widely available) */
+    gst_element_post_message (GST_ELEMENT (sink),
+        gst_message_new_custom (GST_MESSAGE_ELEMENT, GST_OBJECT (sink),
+            gst_structure_new_empty ("frame-ready")));
+  } else {
+    ok = eglSwapBuffers (sink->egldisplay, sink->eglsurface);
+    if (!ok)
+      GST_ERROR_OBJECT (sink, "eglSwapBuffers failed: %d", eglGetError());
+  }
+
+  gst_buffer_unmap (buffer, &src);
+
+  return GST_FLOW_OK;
+}
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  GST_DEBUG_CATEGORY_INIT (gstmir_debug, "mirsink", 0, " mir video sink");
+
+  return gst_element_register (plugin, "mirsink", GST_RANK_MARGINAL,
+      GST_TYPE_MIR_SINK);
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    mirsink,
+    "Mir Video Sink", plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME,
+    GST_PACKAGE_ORIGIN)
diff --git a/ext/mir/gstmirsink.h b/ext/mir/gstmirsink.h
new file mode 100644
index 0000000..6e3edb5
--- /dev/null
+++ b/ext/mir/gstmirsink.h
@@ -0,0 +1,117 @@
+/*
+ * GStreamer Mir video sink
+ * Copyright (C) 2017 Canonical Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __GST_MIR_VIDEO_SINK_H__
+#define __GST_MIR_VIDEO_SINK_H__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <assert.h>
+#include <unistd.h>
+#include <stdint.h>
+
+#define GL_GLEXT_PROTOTYPES
+#define EGL_EGLEXT_PROTOTYPES
+
+#include <mir_toolkit/mir_client_library.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/video/gstvideosink.h>
+#include <gst/video/gstvideometa.h>
+
+#define GST_TYPE_MIR_SINK \
+        (gst_mir_sink_get_type())
+#define GST_MIR_SINK(obj) \
+        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MIR_SINK,GstMirSink))
+#define GST_MIR_SINK_CLASS(klass) \
+        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MIR_SINK,GstMirSinkClass))
+#define GST_IS_MIR_SINK(obj) \
+        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MIR_SINK))
+#define GST_IS_MIR_SINK_CLASS(klass) \
+        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MIR_SINK))
+#define GST_MIR_SINK_GET_CLASS(inst) \
+        (G_TYPE_INSTANCE_GET_CLASS ((inst), GST_TYPE_MIR_SINK, GstMirSinkClass))
+
+typedef struct _GstMirSink GstMirSink;
+typedef struct _GstMirSinkClass GstMirSinkClass;
+
+struct _GstMirSink
+{
+  GstVideoSink parent;
+
+  GstBufferPool *pool;
+
+  GMutex mir_lock;
+
+  /* Whether to export buffers or render them in a local window */
+  gboolean export_buffers;
+  gint video_width;
+  gint video_height;
+  GstVideoFormat video_format;
+
+  MirConnection *conn;
+  MirWindow *window;
+
+  EGLDisplay egldisplay;
+  EGLSurface eglsurface;
+  EGLContext eglctx;
+
+  GLuint vshader, fshader;
+
+  /* Indexes to shader variables */
+  GLint attrpos;
+  GLint attrcordYUV[3];
+  GLint sampYUV[3];
+  GLint yuvmat;
+
+  GLuint text_id[3];
+
+  GLuint prog;
+
+  /* Framebuffer object */
+  GLuint fbo;
+  GLuint render_tex;
+
+  int buf_fd;
+};
+
+struct _GstMirSinkClass
+{
+  GstVideoSinkClass parent;
+};
+
+GType gst_mir_sink_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __GST_MIR_VIDEO_SINK_H__ */
